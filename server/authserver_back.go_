package server

import (
	"context"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/dmfed/basicauth"
	"github.com/dmfed/basicauth/jsonstorage"
)

// New creates instance of http/https server which accepts incoming connections on specified
// ip and port. The server can be lauched with ListenAndServe() or ListenAndServeTLS() methods
// It is callers responsibility to gracefully shutdown server with Shutdown() not Close()
// in order to disconnect from password keeper gracefully
func New(ip, port, pwdfile, mastertoken string, tokenduration time.Duration) (*http.Server, error) {
	handler, err := newMainHandler(pwdfile, tokenduration)
	if err != nil {
		return nil, err
	}
	server := &http.Server{Addr: ip + ":" + port,
		Handler: handler}
	server.RegisterOnShutdown(handler.close)
	// below lines are intended to handle case when we run in manual mode
	// and can not call server.Shutdown()
	interrupts := make(chan os.Signal, 1)
	signal.Notify(interrupts, syscall.SIGTERM, syscall.SIGKILL, syscall.SIGINT)
	go func() {
		sig := <-interrupts
		ctx, cancel := context.WithTimeout(context.Background(), time.Second)
		defer cancel()
		log.Printf("authserver exiting on signal: %v", sig)
		if err := server.Shutdown(ctx); err != nil {
			log.Printf("authserver shutdown error: %v", err)
		} else {
			log.Println("authserver shut down gracefully")
		}
	}()
	return server, nil
}

// MainHandler deals with all incoming requests
type mainHandler struct {
	PasswordKeeper basicauth.PasswordKeeper
	TokenKeeper    basicauth.TokenKeeper
	// Implement stats
}

func newMainHandler(pwdfile string, tokenduration time.Duration) (*mainHandler, error) {
	handler := new(mainHandler)
	pk, err := jsonstorage.OpenJSONPasswordKeeper(pwdfile)
	if err != nil {
		log.Printf("error starting passwords keeper: %v", err)
		return handler, err
	}
	handler.PasswordKeeper = pk
	tk, err := jsonstorage.NewMemSessionTokenKeeper(tokenduration)
	if err != nil {
		log.Printf("error starting tokens keeper: %v", err)
		return handler, err
	}
	handler.TokenKeeper = tk
	return handler, nil
}

// Close signals mainHandler to disconnect from password keeper and token keeper
// and Call their Close() method accordingly.
func (h *mainHandler) close() {
	if err := h.PasswordKeeper.Close(); err != nil {
		log.Printf("error closing passwords keeper: %v", err)
	} else {
		log.Println("closed password keeper")
	}
	if err := h.TokenKeeper.Close(); err != nil {
		log.Printf("error closing tokens keeper: %v", err)
	} else {
		log.Println("closed tokens keeper")
	}
}

func (h *mainHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	w.Write([]byte("Server is running and accepting connections"))
}
